diff --git a/lib/auth/middleware.go b/lib/auth/middleware.go
index c7ee48a7b..d0f975b06 100644
--- a/lib/auth/middleware.go
+++ b/lib/auth/middleware.go
@@ -20,6 +20,7 @@ import (
 	"context"
 	"crypto/tls"
 	"crypto/x509"
+	"fmt"
 	"math"
 	"net"
 	"net/http"
@@ -225,6 +226,7 @@ func (t *TLSServer) Serve() error {
 // and server's GetConfigForClient reloads the list of trusted
 // local and remote certificate authorities
 func (t *TLSServer) GetConfigForClient(info *tls.ClientHelloInfo) (*tls.Config, error) {
+	fmt.Printf("--> GetConfigForClient: %v.\n", info.ServerName)
 	var clusterName string
 	var err error
 	switch info.ServerName {
diff --git a/lib/service/service.go b/lib/service/service.go
index 967b0ce2c..5855b9731 100644
--- a/lib/service/service.go
+++ b/lib/service/service.go
@@ -2630,10 +2630,21 @@ func (process *TeleportProcess) initApps() {
 			},
 		}
 
+		authorizer, err := auth.NewAuthorizer(conn.Client, conn.Client, conn.Client)
+		if err != nil {
+			return trace.Wrap(err)
+		}
+		tlsConfig, err := conn.ServerIdentity.TLSConfig(nil)
+		if err != nil {
+			return trace.Wrap(err)
+		}
+
 		appServer, err := app.New(process.ExitContext(), &app.Config{
 			DataDir:     process.Config.DataDir,
 			AuthClient:  conn.Client,
 			AccessPoint: authClient,
+			Authorizer:  authorizer,
+			TLSConfig:   tlsConfig,
 			GetRotation: process.getRotation,
 			Server:      server,
 		})
diff --git a/lib/srv/app/server.go b/lib/srv/app/server.go
index 5cb74a0a5..d56b6df17 100644
--- a/lib/srv/app/server.go
+++ b/lib/srv/app/server.go
@@ -21,6 +21,8 @@ package app
 
 import (
 	"context"
+	"crypto/tls"
+	"fmt"
 	"net"
 	"net/http"
 	"sync"
@@ -59,6 +61,11 @@ type Config struct {
 	// AccessPoint is a caching client connected to the Auth Server.
 	AccessPoint auth.AccessPoint
 
+	// TLSConfig is the *tls.Config this server presents.
+	TLSConfig *tls.Config
+
+	Authorizer auth.Authorizer
+
 	// GetRotation returns the certificate rotation state.
 	GetRotation RotationGetter
 
@@ -73,15 +80,21 @@ func (c *Config) CheckAndSetDefaults() error {
 		c.Clock = clockwork.NewRealClock()
 	}
 
-	if c.AuthClient == nil {
-		return trace.BadParameter("auth client log missing")
-	}
 	if c.DataDir == "" {
 		return trace.BadParameter("data dir missing")
 	}
+	if c.AuthClient == nil {
+		return trace.BadParameter("auth client log missing")
+	}
 	if c.AccessPoint == nil {
 		return trace.BadParameter("access point missing")
 	}
+	if c.TLSConfig == nil {
+		return trace.BadParameter("tls config missing")
+	}
+	if c.Authorizer == nil {
+		return trace.BadParameter("authorizer missing")
+	}
 	if c.GetRotation == nil {
 		return trace.BadParameter("rotation getter missing")
 	}
@@ -101,6 +114,7 @@ type Server struct {
 	closeFunc    context.CancelFunc
 
 	httpServer *http.Server
+	tlsConfig  *tls.Config
 
 	heartbeat     *srv.Heartbeat
 	dynamicLabels map[string]*labels.Dynamic
@@ -132,9 +146,28 @@ func New(ctx context.Context, c *Config) (*Server, error) {
 
 	s.closeContext, s.closeFunc = context.WithCancel(ctx)
 
+	s.tlsConfig = c.TLSConfig
+	fmt.Printf("--> ClientCAs: %v.\n", s.tlsConfig.ClientCAs)
+	//s.tlsConfig.ClientAuth = tls.VerifyClientCertIfGiven
+	s.tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
+
+	//pool, err := auth.ClientCertPool(s.c.AccessPoint, "example.com")
+	//if err != nil {
+	//	return nil, trace.Wrap(err)
+	//}
+	//s.tlsConfig.ClientCAs = pool
+
+	s.tlsConfig.GetConfigForClient = s.GetConfigForClient
+
+	authMiddleware := &auth.AuthMiddleware{
+		AccessPoint: c.AccessPoint,
+		//AcceptedUsage: []string{teleport.UsageKubeOnly},
+	}
+	authMiddleware.Wrap(s)
+
 	// Create HTTP server that will be forwarding requests to target application.
 	s.httpServer = &http.Server{
-		Handler:           s,
+		Handler:           authMiddleware,
 		ReadHeaderTimeout: defaults.DefaultDialTimeout,
 	}
 
@@ -272,9 +305,13 @@ func (s *Server) ForceHeartbeat() error {
 // HandleConnection takes a connection and wraps it in a listener so it can
 // be passed to http.Serve to process as a HTTP request.
 func (s *Server) HandleConnection(conn net.Conn) {
-	if err := s.httpServer.Serve(newListener(s.closeContext, conn)); err != nil {
+	listener := newListener(s.closeContext, conn)
+	if err := s.httpServer.Serve(tls.NewListener(listener, s.tlsConfig)); err != nil {
 		s.log.Warnf("Failed to handle connection: %v.", err)
 	}
+	//if err := s.httpServer.Serve(newListener(s.closeContext, conn)); err != nil {
+	//	s.log.Warnf("Failed to handle connection: %v.", err)
+	//}
 }
 
 // ServeHTTP will forward the *http.Request to the target application.
@@ -310,24 +347,52 @@ func (s *Server) serveHTTP(w http.ResponseWriter, r *http.Request) error {
 // authenticate will check if request carries a session cookie matching a
 // session in the backend.
 func (s *Server) authenticate(ctx context.Context, r *http.Request) (services.AppSession, error) {
-	sessionID := r.Header.Get(teleport.AppSessionIDHeader)
-	if sessionID == "" {
-		s.log.Warnf("Request missing session ID header.")
-		return nil, trace.AccessDenied("invalid session")
+	//sessionID := r.Header.Get(teleport.AppSessionIDHeader)
+	//if sessionID == "" {
+	//	s.log.Warnf("Request missing session ID header.")
+	//	return nil, trace.AccessDenied("invalid session")
+	//}
+
+	userTypeI := r.Context().Value(auth.ContextUser)
+	switch userTypeI.(type) {
+	case auth.LocalUser:
+		fmt.Printf("--> Got local user!\n")
+	case auth.RemoteUser:
+		fmt.Printf("--> Got remote user!\n")
+	default:
+		fmt.Printf("unknown type: %#v.\n", userTypeI)
 	}
 
-	// Always look for the session in the backend cache first. This allows the
-	// session to be invalidated in the backend and be immediately reflected here.
-	session, err := s.c.AccessPoint.GetAppSession(ctx, sessionID)
+	userContext, err := s.c.Authorizer.Authorize(r.Context())
 	if err != nil {
 		return nil, trace.Wrap(err)
 	}
+
+	app, err := s.getApp(r.Context(), "dumper.example.com")
 	if err != nil {
-		s.log.Warnf("Failed to fetch application session: %v.", err)
-		return nil, trace.AccessDenied("invalid session")
+		return nil, trace.Wrap(err)
+	}
+
+	err = userContext.Checker.CheckAccessToApp(defaults.Namespace, app)
+	if err != nil {
+		return nil, trace.Wrap(err)
 	}
 
-	return session, nil
+	fmt.Printf("--> have access!.\n")
+	return nil, nil
+
+	//// Always look for the session in the backend cache first. This allows the
+	//// session to be invalidated in the backend and be immediately reflected here.
+	//session, err := s.c.AccessPoint.GetAppSession(ctx, sessionID)
+	//if err != nil {
+	//	return nil, trace.Wrap(err)
+	//}
+	//if err != nil {
+	//	s.log.Warnf("Failed to fetch application session: %v.", err)
+	//	return nil, trace.AccessDenied("invalid session")
+	//}
+
+	//return session, nil
 }
 
 // activeConnections returns the number of active connections being proxied.
@@ -363,3 +428,30 @@ func newTransport() (http.RoundTripper, error) {
 
 	return tr, nil
 }
+
+// GetConfigForClient is getting called on every connection
+// and server's GetConfigForClient reloads the list of trusted
+// local and remote certificate authorities
+func (s *Server) GetConfigForClient(info *tls.ClientHelloInfo) (*tls.Config, error) {
+	var clusterName string
+	var err error
+	if info.ServerName != "" {
+		clusterName, err = auth.DecodeClusterName(info.ServerName)
+		if err != nil {
+			if !trace.IsNotFound(err) {
+				//log.Debugf("Ignoring unsupported cluster name name %q.", info.ServerName)
+				clusterName = ""
+			}
+		}
+	}
+	pool, err := auth.ClientCertPool(s.c.AccessPoint, clusterName)
+	if err != nil {
+		fmt.Printf("--> failed to retrieve client pool: %v.\n", trace.DebugReport(err))
+		// this falls back to the default config
+		return nil, nil
+	}
+	//tlsCopy := t.TLS.Clone()
+	tlsCopy := s.c.TLSConfig.Clone()
+	tlsCopy.ClientCAs = pool
+	return tlsCopy, nil
+}
diff --git a/lib/tlsca/ca.go b/lib/tlsca/ca.go
index 74680c4b6..066efb0ab 100644
--- a/lib/tlsca/ca.go
+++ b/lib/tlsca/ca.go
@@ -115,6 +115,11 @@ var KubeUsersASN1ExtensionOID = asn1.ObjectIdentifier{1, 3, 9999, 1, 1}
 // license payload into certificates
 var KubeGroupsASN1ExtensionOID = asn1.ObjectIdentifier{1, 3, 9999, 1, 2}
 
+var AppServevIDASN1ExtensionOID = asn1.ObjectIdentifier{1, 3, 9999, 1, 4}
+var AppClusterNameASN1ExtensionOID = asn1.ObjectIdentifier{1, 3, 9999, 1, 5}
+var AppPublicAddrASN1ExtensionOID = asn1.ObjectIdentifier{1, 3, 9999, 1, 6}
+var AppJWTASN1ExtensionOID = asn1.ObjectIdentifier{1, 3, 9999, 1, 7}
+
 // Subject converts identity to X.509 subject name
 func (id *Identity) Subject() (pkix.Name, error) {
 	rawTraits, err := wrappers.MarshalTraits(&id.Traits)
diff --git a/lib/web/apiserver.go b/lib/web/apiserver.go
index 81cbff818..38c4e73d6 100644
--- a/lib/web/apiserver.go
+++ b/lib/web/apiserver.go
@@ -386,10 +386,11 @@ func NewHandler(cfg Config, opts ...HandlerOption) (*RewritingHandler, error) {
 	// Create application specific handler. This handler handles sessions and
 	// forwarding for AAP applications.
 	appHandler, err := app.NewHandler(&app.HandlerConfig{
-		Clock:       h.clock,
-		AuthClient:  cfg.ProxyClient,
-		AccessPoint: cfg.AccessPoint,
-		ProxyClient: cfg.Proxy,
+		Clock:        h.clock,
+		AuthClient:   cfg.ProxyClient,
+		AccessPoint:  cfg.AccessPoint,
+		ProxyClient:  cfg.Proxy,
+		CipherSuites: cfg.CipherSuites,
 	})
 	if err != nil {
 		return nil, trace.Wrap(err)
diff --git a/lib/web/app/handler.go b/lib/web/app/handler.go
index 41cdb0503..1e2a53c78 100644
--- a/lib/web/app/handler.go
+++ b/lib/web/app/handler.go
@@ -20,6 +20,7 @@ package app
 
 import (
 	"context"
+	"crypto/tls"
 	"fmt"
 	"net"
 	"net/http"
@@ -52,7 +53,8 @@ type HandlerConfig struct {
 	// AccessPoint is caching client to auth.
 	AccessPoint auth.AccessPoint
 	// ProxyClient holds connections to leaf clusters.
-	ProxyClient reversetunnel.Server
+	ProxyClient  reversetunnel.Server
+	CipherSuites []uint16
 }
 
 // CheckAndSetDefaults validates configuration.
@@ -80,7 +82,8 @@ type Handler struct {
 
 	log *logrus.Entry
 
-	tr http.RoundTripper
+	//tr http.RoundTripper
+	tr *http.Transport
 
 	mu    sync.Mutex
 	cache *ttlmap.TTLMap
@@ -255,12 +258,83 @@ func (h *Handler) getForwarder(ctx context.Context, session services.WebSession)
 		return fwd, nil
 	}
 
+	// Works with local cluster.
+	//ca, err := h.c.AuthClient.GetCertAuthority(services.CertAuthID{
+	//	Type:       services.HostCA,
+	//	DomainName: "example.com",
+	//}, false)
+	//if err != nil {
+	//	return nil, trace.Wrap(err)
+	//}
+	//certPool, err := services.CertPool(ca)
+	//if err != nil {
+	//	return nil, trace.Wrap(err)
+	//}
+	//tlsConfig := utils.TLSConfig(h.c.CipherSuites)
+	//tlsCert, err := tls.X509KeyPair(session.GetTLSCert(), session.GetPriv())
+	//if err != nil {
+	//	return nil, trace.Wrap(err, "failed to parse TLS cert and key")
+	//}
+	//tlsConfig.Certificates = []tls.Certificate{tlsCert}
+	//tlsConfig.RootCAs = certPool
+	//// TODO(russjones): This might be due to hostname mistmatch?
+	////tlsConfig.InsecureSkipVerify = true
+	////tlsConfig.ServerName = auth.EncodeClusterName("example.com")
+	//tlsConfig.ServerName = "084449f1-c71b-4fdf-b49f-b4304d2a1f1f.example.com"
+	//cert := tlsConfig.Certificates[0]
+	//tlsConfig.Certificates = nil
+	//tlsConfig.GetClientCertificate = func(_ *tls.CertificateRequestInfo) (*tls.Certificate, error) {
+	//	fmt.Printf("--> sending cert.\n")
+	//	return &cert, nil
+	//}
+	//tlsConfig.ServerName = "server04"
+	////tlsConfig.BuildNameToCertificate()
+	//tr, _ := newTransport(h.c.ProxyClient)
+	//tr.TLSClientConfig = tlsConfig
+
+	ca, err := h.c.AuthClient.GetCertAuthority(services.CertAuthID{
+		Type:       services.HostCA,
+		DomainName: "remote.example.com",
+	}, false)
+	if err != nil {
+		return nil, trace.Wrap(err)
+	}
+	certPool, err := services.CertPool(ca)
+	if err != nil {
+		return nil, trace.Wrap(err)
+	}
+	tlsConfig := utils.TLSConfig(h.c.CipherSuites)
+	tlsCert, err := tls.X509KeyPair(session.GetTLSCert(), session.GetPriv())
+	if err != nil {
+		return nil, trace.Wrap(err, "failed to parse TLS cert and key")
+	}
+	tlsConfig.Certificates = []tls.Certificate{tlsCert}
+	tlsConfig.RootCAs = certPool
+	// TODO(russjones): This might be due to hostname mistmatch?
+	//tlsConfig.InsecureSkipVerify = true
+	//tlsConfig.ServerName = auth.EncodeClusterName("example.com")
+	//tlsConfig.ServerName = "a9c770b9-3b7c-4cbf-99a4-ee1821bfaae0.remote.example.com"
+	cert := tlsConfig.Certificates[0]
+	tlsConfig.Certificates = nil
+	tlsConfig.GetClientCertificate = func(_ *tls.CertificateRequestInfo) (*tls.Certificate, error) {
+		fmt.Printf("--> sending cert.\n")
+		return &cert, nil
+	}
+	tlsConfig.ServerName = "server06" // <<-- surprusing dialing has to happen by host here.
+	//tlsConfig.BuildNameToCertificate()
+
+	tr, _ := newTransport(h.c.ProxyClient)
+	tr.TLSClientConfig = tlsConfig
+
 	// Create the forwarder.
 	fwder, err := newForwarder(forwarderConfig{
-		uri:       fmt.Sprintf("http://%v.%v", session.GetServerID(), session.GetClusterName()),
+		uri: fmt.Sprintf("https://%v.%v", session.GetServerID(), session.GetClusterName()),
+		//uri:       "https://" + teleport.APIDomain,
+		//uri:       "https://server04",
 		sessionID: session.GetSessionID(),
-		tr:        h.tr,
-		log:       h.log,
+		//tr:        h.tr,
+		tr:  tr,
+		log: h.log,
 	})
 	if err != nil {
 		return nil, trace.Wrap(err)
@@ -362,7 +436,7 @@ func (f *forwarder) RoundTrip(r *http.Request) (*http.Response, error) {
 	// Update the target address of the request so it's forwarded correctly.
 	// Format is always serverID.clusterName.
 	r.URL.Scheme = f.uri.Scheme
-	r.URL.Host = f.uri.Host
+	r.URL.Host = "server06" //f.uri.Host
 
 	resp, err := f.c.tr.RoundTrip(r)
 	if err != nil {
@@ -395,7 +469,7 @@ func (f *forwarder) Rewrite(r *http.Request) {
 // newTransport creates a http.RoundTripper that uses the reverse tunnel
 // subsystem to build the connection. This allows re-use of the transports
 // connection pooling logic instead of needing to write and maintain our own.
-func newTransport(proxyClient reversetunnel.Server) (http.RoundTripper, error) {
+func newTransport(proxyClient reversetunnel.Server) (*http.Transport, error) {
 	// Clone the default transport to pick up sensible defaults.
 	defaultTransport, ok := http.DefaultTransport.(*http.Transport)
 	if !ok {
@@ -419,11 +493,13 @@ func newTransport(proxyClient reversetunnel.Server) (http.RoundTripper, error) {
 	// the connection pool maintained by the transport to differentiate
 	// connections to different application proxy hosts.
 	tr.DialContext = func(ctx context.Context, network string, addr string) (net.Conn, error) {
-		serverID, clusterName, err := extract(addr)
-		if err != nil {
-			return nil, trace.Wrap(err)
-		}
-		clusterClient, err := proxyClient.GetSite(clusterName)
+		//serverID, clusterName, err := extract(addr)
+		//if err != nil {
+		//	return nil, trace.Wrap(err)
+		//}
+		//clusterClient, err := proxyClient.GetSite(clusterName)
+		//	clusterClient, err := proxyClient.GetSite("example.com")
+		clusterClient, err := proxyClient.GetSite("remote.example.com")
 		if err != nil {
 			return nil, trace.Wrap(err)
 		}
@@ -431,9 +507,11 @@ func newTransport(proxyClient reversetunnel.Server) (http.RoundTripper, error) {
 		conn, err := clusterClient.Dial(reversetunnel.DialParams{
 			// The "From" and "To" addresses don't mean anything for tunnel dialing,
 			// so they are simply filled out with dummy values.
-			From:     &utils.NetAddr{AddrNetwork: "tcp", Addr: "@proxy"},
-			To:       &utils.NetAddr{AddrNetwork: "tcp", Addr: "@app"},
-			ServerID: fmt.Sprintf("%v.%v", serverID, clusterName),
+			From: &utils.NetAddr{AddrNetwork: "tcp", Addr: "@proxy"},
+			To:   &utils.NetAddr{AddrNetwork: "tcp", Addr: "@app"},
+			//ServerID: fmt.Sprintf("%v.%v", serverID, clusterName),
+			//ServerID: "084449f1-c71b-4fdf-b49f-b4304d2a1f1f.example.com",
+			ServerID: "a9c770b9-3b7c-4cbf-99a4-ee1821bfaae0.remote.example.com",
 			ConnType: services.AppTunnel,
 		})
 		if err != nil {
@@ -450,6 +528,7 @@ func newTransport(proxyClient reversetunnel.Server) (http.RoundTripper, error) {
 func extract(address string) (string, string, error) {
 	// Strip port suffix.
 	address = strings.TrimSuffix(address, ":80")
+	address = strings.TrimSuffix(address, ":443")
 
 	// Split into two parts: serverID and clusterName.
 	index := strings.Index(address, ".")
diff --git a/vendor/github.com/prometheus/procfs/go.mod b/vendor/github.com/prometheus/procfs/go.mod
index b2f8cca93..e24cef23c 100644
--- a/vendor/github.com/prometheus/procfs/go.mod
+++ b/vendor/github.com/prometheus/procfs/go.mod
@@ -1,5 +1,7 @@
 module github.com/prometheus/procfs
 
+go 1.14
+
 require (
 	github.com/google/go-cmp v0.3.0
 	golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4
